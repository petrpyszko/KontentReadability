import { enumHelper } from '@kentico/kontent-core';
import { defaultCollissionResolver } from '../config';
import { ElementDecorators, Elements, ElementType } from '../elements';
import { Link, RichTextImage, } from '../models';
import { richTextResolver, stronglyTypedResolver, urlSlugResolver } from '../resolvers';
var ElementMapper = /** @class */ (function () {
    function ElementMapper(config, richTextHtmlParser) {
        this.config = config;
        this.richTextHtmlParser = richTextHtmlParser;
        this.defaultLinkedItemWrapperTag = 'p';
        this.defaultLinkedItemWrapperClasses = ['kc-linked-item-wrapper'];
    }
    /**
     * Maps all element in given content item and returns strongly typed content item based on the resolver specified
     * in DeliveryClientConfig
     */
    ElementMapper.prototype.mapElements = function (data) {
        var _this = this;
        // return processed item if possible (to avoid infinite recursion)
        var processedItem = data.processedItems[data.item.system.codename];
        if (processedItem) {
            // item was already resolved, return it
            return {
                item: processedItem,
                processedItems: data.processedItems,
                preparedItems: data.preparedItems,
                processingStartedForCodenames: data.processingStartedForCodenames
            };
        }
        var elementCodenames = Object.getOwnPropertyNames(data.item.elements);
        var itemInstance = data.preparedItems[data.item.system.codename];
        if (!itemInstance) {
            // item is not present in response, no need to do any mapping
            return undefined;
        }
        elementCodenames.forEach(function (elementCodename) {
            var elementMap = _this.resolveElementMap(itemInstance, elementCodename);
            var elementWrapper = {
                contentItemSystem: data.item.system,
                rawElement: data.item.elements[elementCodename],
                propertyName: elementMap.resolvedName
            };
            if (elementMap.shouldMapElement) {
                var mappedElement = _this.mapElement({
                    elementWrapper: elementWrapper,
                    item: itemInstance,
                    preparedItems: data.preparedItems,
                    processingStartedForCodenames: data.processingStartedForCodenames,
                    processedItems: data.processedItems,
                    queryConfig: data.queryConfig
                });
                // set mapped element to item instance
                itemInstance[elementMap.resolvedName] = mappedElement;
            }
        });
        return {
            item: itemInstance,
            processedItems: data.processedItems,
            preparedItems: data.preparedItems,
            processingStartedForCodenames: data.processingStartedForCodenames
        };
    };
    ElementMapper.prototype.mapElement = function (data) {
        var elementType = enumHelper.getEnumFromValue(ElementType, data.elementWrapper.rawElement.type);
        if (elementType) {
            if (elementType === ElementType.ModularContent) {
                return this.mapLinkedItemsElement({
                    elementWrapper: data.elementWrapper,
                    preparedItems: data.preparedItems,
                    processingStartedForCodenames: data.processingStartedForCodenames,
                    processedItems: data.processedItems,
                    queryConfig: data.queryConfig
                });
            }
            if (elementType === ElementType.Text) {
                return this.mapTextElement(data.elementWrapper);
            }
            if (elementType === ElementType.Asset) {
                return this.mapAssetsElement(data.elementWrapper);
            }
            if (elementType === ElementType.Number) {
                return this.mapNumberElement(data.elementWrapper);
            }
            if (elementType === ElementType.MultipleChoice) {
                return this.mapMultipleChoiceElement(data.elementWrapper);
            }
            if (elementType === ElementType.DateTime) {
                return this.mapDateTimeElement(data.elementWrapper);
            }
            if (elementType === ElementType.RichText) {
                return this.mapRichTextElement(data.item, data.elementWrapper, data.queryConfig, data.processedItems, data.processingStartedForCodenames, data.preparedItems);
            }
            if (elementType === ElementType.UrlSlug) {
                return this.mapUrlSlugElement(data.elementWrapper, data.item, data.queryConfig);
            }
            if (elementType === ElementType.Taxonomy) {
                return this.mapTaxonomyElement(data.elementWrapper);
            }
            if (elementType === ElementType.Custom) {
                return this.mapCustomElement(data.elementWrapper);
            }
        }
        console.warn("Could not map element '" + data.elementWrapper.rawElement.name + "' of type '" + data.elementWrapper.rawElement.type + "'. Returning unknown element instead.");
        return this.mapUnknowElement(data.elementWrapper);
    };
    ElementMapper.prototype.mapRichTextElement = function (item, elementWrapper, queryConfig, processedItems, processingStartedForCodenames, preparedItems) {
        var _this = this;
        // get all linked items nested in rich text
        var richTextLinkedItems = [];
        var rawElement = elementWrapper.rawElement;
        if (rawElement.modular_content) {
            if (Array.isArray(rawElement.modular_content)) {
                rawElement.modular_content.forEach(function (codename) {
                    // get linked item and check if it exists (it might not be included in response due to 'Depth' parameter)
                    var preparedItem = preparedItems[codename];
                    // first try to get existing item
                    var existingLinkedItem = _this.getOrSaveLinkedItemForElement(codename, rawElement, queryConfig, processedItems, processingStartedForCodenames, preparedItems);
                    if (existingLinkedItem) {
                        // item was found, add it to linked items
                        richTextLinkedItems.push(existingLinkedItem);
                    }
                    else {
                        var throwErrorForMissingLinkedItems = false;
                        // check if errors should be thrown for missing linked items
                        if (queryConfig.throwErrorForMissingLinkedItems === false ||
                            queryConfig.throwErrorForMissingLinkedItems === true) {
                            // variable is a boolean
                            throwErrorForMissingLinkedItems = queryConfig.throwErrorForMissingLinkedItems;
                        }
                        // throw error if raw item is not available and errors are not skipped
                        if (!preparedItem) {
                            var msg = "Mapping RichTextElement element '" + rawElement.name + "' failed because referenced linked item with codename '" + codename + "' could not be found in Delivery response.\n                            Increasing 'depth' parameter may solve this issue as it will include nested items. Alternatively you may disable 'throwErrorForMissingLinkedItems' in your query";
                            if (throwErrorForMissingLinkedItems) {
                                throw Error(msg);
                            }
                        }
                        // item was not found or not yet resolved
                        if (preparedItem) {
                            var mappedLinkedItemResult = _this.mapElements({
                                item: preparedItem._raw,
                                preparedItems: preparedItems,
                                processingStartedForCodenames: processingStartedForCodenames,
                                processedItems: processedItems,
                                queryConfig: queryConfig
                            });
                            // add mapped linked item to result
                            if (mappedLinkedItemResult) {
                                richTextLinkedItems.push(mappedLinkedItemResult.item);
                            }
                        }
                    }
                });
            }
        }
        // extract and map links & images
        var links = this.mapRichTextLinks(rawElement.links);
        var images = this.mapRichTextImages(rawElement.images);
        return new Elements.RichTextElement(elementWrapper, rawElement.modular_content, {
            links: links,
            resolveRichTextFunc: function () {
                return richTextResolver.resolveData(item.system.codename, rawElement.value, elementWrapper.propertyName, {
                    enableAdvancedLogging: _this.config.isDeveloperMode ? _this.config.isDeveloperMode : false,
                    getGlobalUrlSlugResolver: function (type) { return _this.getGlobalUrlSlugResolverForType(type); },
                    images: images,
                    richTextHtmlParser: _this.richTextHtmlParser,
                    getLinkedItem: function (codename) {
                        return _this.getOrSaveLinkedItemForElement(codename, rawElement, queryConfig, processedItems, processingStartedForCodenames, preparedItems);
                    },
                    links: links,
                    queryConfig: queryConfig,
                    linkedItemWrapperTag: _this.config.linkedItemResolver && _this.config.linkedItemResolver.linkedItemWrapperTag
                        ? _this.config.linkedItemResolver.linkedItemWrapperTag
                        : _this.defaultLinkedItemWrapperTag,
                    linkedItemWrapperClasses: _this.config.linkedItemResolver && _this.config.linkedItemResolver.linkedItemWrapperClasses
                        ? _this.config.linkedItemResolver.linkedItemWrapperClasses
                        : _this.defaultLinkedItemWrapperClasses
                });
            },
            images: images
        });
    };
    ElementMapper.prototype.mapDateTimeElement = function (elementWrapper) {
        return new Elements.DateTimeElement(elementWrapper);
    };
    ElementMapper.prototype.mapMultipleChoiceElement = function (elementWrapper) {
        return new Elements.MultipleChoiceElement(elementWrapper);
    };
    ElementMapper.prototype.mapNumberElement = function (elementWrapper) {
        return new Elements.NumberElement(elementWrapper);
    };
    ElementMapper.prototype.mapTextElement = function (elementWrapper) {
        return new Elements.TextElement(elementWrapper);
    };
    ElementMapper.prototype.mapAssetsElement = function (elementWrapper) {
        return new Elements.AssetsElement(elementWrapper);
    };
    ElementMapper.prototype.mapTaxonomyElement = function (elementWrapper) {
        return new Elements.TaxonomyElement(elementWrapper);
    };
    ElementMapper.prototype.mapUnknowElement = function (elementWrapper) {
        return new Elements.UnknownElement(elementWrapper);
    };
    ElementMapper.prototype.mapCustomElement = function (elementWrapper) {
        // try to find element resolver
        if (this.config.elementResolver) {
            var customElementClass = this.config.elementResolver(elementWrapper);
            if (customElementClass) {
                return customElementClass;
            }
        }
        return new Elements.DefaultCustomElement(elementWrapper);
    };
    ElementMapper.prototype.mapUrlSlugElement = function (elementWrapper, item, queryConfig) {
        var _this = this;
        var resolver = this.getUrlSlugResolverForElement(item, elementWrapper, queryConfig);
        return new Elements.UrlSlugElement(elementWrapper, {
            resolveLinkFunc: function () {
                return urlSlugResolver.resolveUrl({
                    elementName: elementWrapper.propertyName,
                    elementValue: elementWrapper.rawElement.value,
                    item: item,
                    enableAdvancedLogging: _this.config.isDeveloperMode ? _this.config.isDeveloperMode : false,
                    resolver: resolver
                }).url || '';
            }
        });
    };
    ElementMapper.prototype.mapLinkedItemsElement = function (data) {
        var _this = this;
        // prepare linked items
        var linkedItems = [];
        // value = array of item codenames
        var linkedItemCodenames = data.elementWrapper.rawElement.value;
        linkedItemCodenames.forEach(function (codename) {
            var linkedItem = _this.getOrSaveLinkedItemForElement(codename, data.elementWrapper.rawElement, data.queryConfig, data.processedItems, data.processingStartedForCodenames, data.preparedItems);
            if (linkedItem) {
                // add item to result
                linkedItems.push(linkedItem);
            }
            else {
                // item was not found
                if (_this.config.isDeveloperMode) {
                    // tslint:disable-next-line:max-line-length
                    console.warn("Linked item with codename '" + codename + "' in linked items element '" + data.elementWrapper.rawElement.name + "' of '" + data.elementWrapper.rawElement.type + "' type could not be found. If you require this item, consider increasing 'depth' of your query. This warning can be turned off by disabling 'enableAdvancedLogging' option.");
                }
            }
        });
        return new Elements.LinkedItemsElement(data.elementWrapper, linkedItems);
    };
    ElementMapper.prototype.getUrlSlugResolverForElement = function (item, elementWrapper, queryConfig) {
        // query `urlSlugResolver` has priority over global resolver
        if (queryConfig.urlSlugResolver) {
            return queryConfig.urlSlugResolver;
        }
        if (item._config && item._config.urlSlugResolver) {
            return item._config.urlSlugResolver;
        }
        // resolve default link value
        return function () { return elementWrapper.rawElement.value; };
    };
    ElementMapper.prototype.getOrSaveLinkedItemForElement = function (codename, element, queryConfig, processedItems, mappingStartedForCodenames, preparedItems) {
        // first check if item was already resolved and return it if it was
        var processedItem = processedItems[codename];
        if (processedItem) {
            // item was already resolved
            return processedItem;
        }
        var preparedItem = preparedItems[codename];
        if (mappingStartedForCodenames.includes(codename)) {
            return preparedItem;
        }
        mappingStartedForCodenames.push(codename);
        // by default errors are not thrown
        var throwErrorForMissingLinkedItems = queryConfig.throwErrorForMissingLinkedItems === true ? true : false;
        // throw error if item is not in response and errors are not skipped
        if (!preparedItem) {
            if (throwErrorForMissingLinkedItems) {
                throw Error("Linked item with codename '" + codename + "' could not be found in Delivery response.\n                This linked item was requested by '" + element.name + "' element of '" + element.type + "'.\n                Error can usually be solved by increasing 'Depth' parameter of your query.\n                Alternatively, you may prevent this error by disabling 'throwErrorForMissingLinkedItems' in query configuration.");
            }
            return undefined;
        }
        var mappedLinkedItem;
        // original resolving if item is still undefined
        var mappedLinkedItemResult = this.mapElements({
            item: preparedItem._raw,
            preparedItems: preparedItems,
            processingStartedForCodenames: mappingStartedForCodenames,
            processedItems: processedItems,
            queryConfig: queryConfig
        });
        if (mappedLinkedItemResult) {
            mappedLinkedItem = mappedLinkedItemResult.item;
            // add to processed items
            processedItems[codename] = mappedLinkedItem;
        }
        return mappedLinkedItem;
    };
    ElementMapper.prototype.mapRichTextLinks = function (linksJson) {
        var links = [];
        for (var _i = 0, _a = Object.keys(linksJson); _i < _a.length; _i++) {
            var linkId = _a[_i];
            var linkRaw = linksJson[linkId];
            links.push(new Link({
                codename: linkRaw.codename,
                linkId: linkId,
                urlSlug: linkRaw.url_slug,
                type: linkRaw.type
            }));
        }
        return links;
    };
    ElementMapper.prototype.mapRichTextImages = function (imagesJson) {
        var images = [];
        for (var _i = 0, _a = Object.keys(imagesJson); _i < _a.length; _i++) {
            var imageId = _a[_i];
            var imageRaw = imagesJson[imageId];
            images.push(new RichTextImage({
                description: imageRaw.description,
                imageId: imageRaw.image_id,
                url: imageRaw.url,
                height: imageRaw.height,
                width: imageRaw.width
            }));
        }
        return images;
    };
    ElementMapper.prototype.resolveElementMap = function (item, originalElementCodename) {
        var resolvedElementPropertyName = undefined;
        // resolve using property resolver
        if (item._config && item._config.propertyResolver) {
            resolvedElementPropertyName = item._config.propertyResolver(originalElementCodename);
        }
        // if property hasn't been resolved, try getting name using decorator
        if (resolvedElementPropertyName === originalElementCodename || !resolvedElementPropertyName) {
            resolvedElementPropertyName = ElementDecorators.getPropertyName(item, originalElementCodename);
        }
        if (!resolvedElementPropertyName) {
            // use original element codename
            resolvedElementPropertyName = originalElementCodename;
        }
        // check for collissions
        if (this.collidesWithAnotherProperty(resolvedElementPropertyName, item)) {
            // try to resolve collission using dedicated resolver
            var collisionResolver = this.getCollisionResolver();
            resolvedElementPropertyName = collisionResolver(resolvedElementPropertyName);
            // verify again if the new element collides
            if (this.collidesWithAnotherProperty(resolvedElementPropertyName, item)) {
                console.warn("Element '" + resolvedElementPropertyName + "' collides with another element in same type. Element mapping is skipped. Source item: '" + item.system.codename + "'");
                return {
                    shouldMapElement: false,
                    resolvedName: ''
                };
            }
        }
        return {
            resolvedName: resolvedElementPropertyName,
            shouldMapElement: true
        };
    };
    ElementMapper.prototype.getGlobalUrlSlugResolverForType = function (type) {
        var item = stronglyTypedResolver.createEmptyItemInstanceOfType(type, this.config.typeResolvers || []);
        if (item && item._config && item._config.urlSlugResolver) {
            return item._config.urlSlugResolver;
        }
        return undefined;
    };
    ElementMapper.prototype.getCollisionResolver = function () {
        return this.config.collisionResolver ? this.config.collisionResolver : defaultCollissionResolver;
    };
    ElementMapper.prototype.collidesWithAnotherProperty = function (elementName, item) {
        return item[elementName] ? true : false;
    };
    return ElementMapper;
}());
export { ElementMapper };
//# sourceMappingURL=element.mapper.js.map