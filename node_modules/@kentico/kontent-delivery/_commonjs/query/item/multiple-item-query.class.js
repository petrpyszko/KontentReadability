"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultipleItemQuery = void 0;
var models_1 = require("../../models");
var base_item_query_class_1 = require("./base-item-query.class");
var MultipleItemQuery = /** @class */ (function (_super) {
    __extends(MultipleItemQuery, _super);
    function MultipleItemQuery(config, queryService) {
        var _this = _super.call(this, config, queryService) || this;
        _this.config = config;
        _this.queryService = queryService;
        return _this;
    }
    /**
     * Adds information about the total number of content items matching your query.
     * When set to true, the pagination object returned in the API response contains
     * an additional total_count property.
     */
    MultipleItemQuery.prototype.includeTotalCountParameter = function () {
        this.parameters.push(new models_1.Parameters.IncludeTotalCountParameter());
        return this;
    };
    /**
     * Gets only item of given type
     * @param type Codename of type to get
     */
    MultipleItemQuery.prototype.type = function (type) {
        this.parameters.push(new models_1.Filters.TypeFilter(type));
        return this;
    };
    /**
     * Gets items of given types (logical or)
     * I.e. get items of either 'Actor' or 'Movie' type
     * @param types Types to get
     */
    MultipleItemQuery.prototype.types = function (types) {
        this.parameters.push(new models_1.Filters.TypeFilter(types));
        return this;
    };
    /**
     * Gets only item from given collection
     * @param collection Codename of collection to get
     */
    MultipleItemQuery.prototype.collection = function (collection) {
        this.parameters.push(new models_1.Filters.CollectionFilter(collection));
        return this;
    };
    /**
     * Gets items from given collections (logical or)
     * I.e. get items of either 'default' or 'christmas-campaign' collection
     * @param collections Collections to get
     */
    MultipleItemQuery.prototype.collections = function (collections) {
        this.parameters.push(new models_1.Filters.CollectionFilter(collections));
        return this;
    };
    /**
    * Empty filter condition
    * @param element Element with empty value
    */
    MultipleItemQuery.prototype.emptyFilter = function (element) {
        this.parameters.push(new models_1.Filters.EmptyFilter(element));
        return this;
    };
    /**
     * Not empty filter condition
     * @param element Element with non-empty value
     */
    MultipleItemQuery.prototype.notEmptyFilter = function (element) {
        this.parameters.push(new models_1.Filters.NotEmptyFilter(element));
        return this;
    };
    /**
     * Equals filter condition
     * @param element Element to filter. Example: 'elements.movie'
     * @param value Value to match. Example: 'Kingsman'
     */
    MultipleItemQuery.prototype.equalsFilter = function (element, value) {
        this.parameters.push(new models_1.Filters.EqualsFilter(element, value));
        return this;
    };
    /**
     * Not equals filter condition
     * @param element Element to filter. Example: 'elements.movie'
     * @param value Value to match. Example: 'Kingsman'
     */
    MultipleItemQuery.prototype.notEqualsFilter = function (element, value) {
        this.parameters.push(new models_1.Filters.NotEqualsFilter(element, value));
        return this;
    };
    /**
     * All filter
     * @param element Element to filter.
     * @param values Values
     */
    MultipleItemQuery.prototype.allFilter = function (element, values) {
        this.parameters.push(new models_1.Filters.AllFilter(element, values));
        return this;
    };
    /**
     * Any filter
     * @param element Element to filter.
     * @param values Values
     */
    MultipleItemQuery.prototype.anyFilter = function (element, values) {
        this.parameters.push(new models_1.Filters.AnyFilter(element, values));
        return this;
    };
    /**
     * Contains filter
     * @param element Element to filter.
     * @param values Values
     */
    MultipleItemQuery.prototype.containsFilter = function (element, values) {
        this.parameters.push(new models_1.Filters.ContainsFilter(element, values));
        return this;
    };
    /**
     * Greater then filter
     * @param element Element to filter.
     * @param value Value
     */
    MultipleItemQuery.prototype.greaterThanFilter = function (element, value) {
        this.parameters.push(new models_1.Filters.GreaterThanFilter(element, value));
        return this;
    };
    /**
     * Greater then or equals filter
     * @param element Element to filter.
     * @param value Value
     */
    MultipleItemQuery.prototype.greaterThanOrEqualFilter = function (element, value) {
        this.parameters.push(new models_1.Filters.GreaterThanOrEqualFilter(element, value));
        return this;
    };
    /**
     * Indicates depth of query that affects loading of nested linked items.
     * @param depth Depth of the query (> 0)
     */
    MultipleItemQuery.prototype.depthParameter = function (depth) {
        this.parameters.push(new models_1.Parameters.DepthParameter(depth));
        return this;
    };
    /**
     * In filter
     * @param element Element to filter.
     * @param values Values
     */
    MultipleItemQuery.prototype.inFilter = function (element, values) {
        this.parameters.push(new models_1.Filters.InFilter(element, values));
        return this;
    };
    /**
     * Not in filter
     * @param element Element to filter.
     * @param values Values
     */
    MultipleItemQuery.prototype.notInFilter = function (element, values) {
        this.parameters.push(new models_1.Filters.NotInFilter(element, values));
        return this;
    };
    /**
     * Less then filter
     * @param element Element to filter.
     * @param value Value
     */
    MultipleItemQuery.prototype.lessThanFilter = function (element, value) {
        this.parameters.push(new models_1.Filters.LessThanFilter(element, value));
        return this;
    };
    /**
     * @param element Element to filter.
     * @param value Value
     */
    MultipleItemQuery.prototype.lessThanOrEqualFilter = function (element, value) {
        this.parameters.push(new models_1.Filters.LessThanOrEqualFilter(element, value));
        return this;
    };
    /**
     * @param element Element to filter.
     * @param lowerValue Lower value of range (e.g. 2)
     * @param higherValue Higher value of range (e.g. 10)
     */
    MultipleItemQuery.prototype.rangeFilter = function (element, lowerValue, higherValue) {
        this.parameters.push(new models_1.Filters.RangeFilter(element, lowerValue, higherValue));
        return this;
    };
    /**
     * Limits the number of items returned by query
     * @param limit Number of items to load
     */
    MultipleItemQuery.prototype.limitParameter = function (limit) {
        this.parameters.push(new models_1.Parameters.LimitParameter(limit));
        return this;
    };
    /**
     * Orders query based on given element and sort order
     * @param element Element by which to order
     * @param sortOrder Asc/Desc order type
     */
    MultipleItemQuery.prototype.orderParameter = function (element, sortOrder) {
        this.parameters.push(new models_1.Parameters.OrderParameter(element, sortOrder));
        return this;
    };
    /**
     * Sets descending order on given element
     * @param element Element by which to order
     */
    MultipleItemQuery.prototype.orderByDescending = function (element) {
        this.parameters.push(new models_1.Parameters.OrderParameter(element, models_1.SortOrder.desc));
        return this;
    };
    /**
     * Sets Ascending order on given element
     * @param element Element by which to order
     */
    MultipleItemQuery.prototype.orderByAscending = function (element) {
        this.parameters.push(new models_1.Parameters.OrderParameter(element, models_1.SortOrder.asc));
        return this;
    };
    /**
     * Skips the selected number of items
     * @param skip Number of items to skip
     */
    MultipleItemQuery.prototype.skipParameter = function (skip) {
        this.parameters.push(new models_1.Parameters.SkipParameter(skip));
        return this;
    };
    /**
     * Gets the runnable Observable
     */
    MultipleItemQuery.prototype.toObservable = function () {
        return _super.prototype.runMultipleItemsQuery.call(this);
    };
    /**
     * Gets 'Url' representation of query
     */
    MultipleItemQuery.prototype.getUrl = function () {
        return _super.prototype.getMultipleItemsQueryUrl.call(this);
    };
    return MultipleItemQuery;
}(base_item_query_class_1.BaseItemQuery));
exports.MultipleItemQuery = MultipleItemQuery;
//# sourceMappingURL=multiple-item-query.class.js.map