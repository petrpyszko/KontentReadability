import { ContentType, ContentTypeSystemAttributes, GenericElement, GenericElementOption } from '../models';
var TypeMapper = /** @class */ (function () {
    function TypeMapper() {
    }
    TypeMapper.prototype.mapSingleType = function (response) {
        return this.mapType(response);
    };
    TypeMapper.prototype.mapMultipleTypes = function (response) {
        var that = this;
        return response.types.map(function (type) {
            return that.mapType(type);
        });
    };
    TypeMapper.prototype.mapType = function (type) {
        if (!type) {
            throw Error("Cannot map type");
        }
        if (!type.elements) {
            throw Error("Cannot map type elements");
        }
        var typeSystem = new ContentTypeSystemAttributes({
            codename: type.system.codename,
            id: type.system.id,
            name: type.system.name,
            lastModified: type.system.last_modified
        });
        var elements = [];
        var elementNames = Object.getOwnPropertyNames(type.elements);
        elementNames.forEach(function (elementName) {
            var typeElement = type.elements[elementName];
            if (!typeElement) {
                throw Error("Cannot find element '" + elementName + "' on type '" + type + "'");
            }
            // use json property as a codename of the type element
            var elementCodename = elementName;
            // extra properties for certain element types
            var taxonomyGroup = typeElement.taxonomy_group;
            var options = [];
            // some elements can contain options
            var rawOptions = typeElement.options;
            if (rawOptions) {
                if (!Array.isArray(rawOptions)) {
                    throw Error("Content type 'options' property has to be an array");
                }
                rawOptions.forEach(function (rawOption) {
                    options.push(new GenericElementOption(rawOption.name, rawOption.codename));
                });
            }
            elements.push(new GenericElement({
                codename: elementCodename,
                taxonomyGroup: taxonomyGroup,
                options: options,
                name: typeElement.name,
                type: typeElement.type
            }));
        });
        return new ContentType({
            system: typeSystem,
            elements: elements
        });
    };
    return TypeMapper;
}());
export { TypeMapper };
//# sourceMappingURL=type.mapper.js.map