import { throwError, timer } from 'rxjs';
import { flatMap } from 'rxjs/operators';
import { retryService } from './retry-service';
var ObservableRetryStrategy = /** @class */ (function () {
    function ObservableRetryStrategy() {
        this.strategy = function (options, internal) { return function (errorObs) {
            return errorObs.pipe(flatMap(function (error, i) {
                var canRetryError = options.canRetryError(error);
                if (!canRetryError) {
                    // request cannot be retried
                    return throwError(error);
                }
                var retryAttempt = i + 1;
                var maximumRetryAttemptsMet = retryAttempt > options.maxAttempts;
                if (maximumRetryAttemptsMet) {
                    // request cannot be retried anymore due to maximum attempts
                    return throwError(error);
                }
                var retryInTimeResult = retryService.canRetryInTime(internal.startTime, options.maxCumulativeWaitTimeMs);
                if (!retryInTimeResult.canRetry) {
                    // request should not be retried anymore as allowed time expired
                    return throwError(error);
                }
                // get wait time
                var retryAfter = retryService.tryGetRetryAfterInMsFromError(error);
                var waitTime = retryService.getNextWaitTimeMs(options.addJitter, options.deltaBackoffMs, retryAttempt, retryAfter);
                // debug log attempt
                retryService.debugLogAttempt(retryAttempt, waitTime);
                return timer(waitTime);
            }));
        }; };
    }
    return ObservableRetryStrategy;
}());
export { ObservableRetryStrategy };
export var observableRetryStrategy = new ObservableRetryStrategy();
//# sourceMappingURL=observable-retry-strategy.js.map