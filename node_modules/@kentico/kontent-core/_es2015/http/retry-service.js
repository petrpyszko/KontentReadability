import { extractHeadersFromAxiosResponse } from './headers-helper';
var RetryService = /** @class */ (function () {
    function RetryService() {
        var _this = this;
        this.retryAfterHeaderName = 'Retry-After';
        this.useRetryForStatusCodes = [408, 429, 500, 502, 503, 504];
        this.defaultRetryPolicy = {
            addJitter: true,
            deltaBackoffMs: 1000,
            maxCumulativeWaitTimeMs: 30000,
            maxAttempts: 20,
            canRetryError: function (error) { return _this.canRetryErrorDefault(error); }
        };
    }
    RetryService.prototype.getRetryStrategyFromStrategyOptions = function (retryOptions) {
        if (!retryOptions) {
            return this.defaultRetryPolicy;
        }
        return retryOptions;
    };
    RetryService.prototype.canRetryInTime = function (startTime, maxCumulativeWaitTimeMs) {
        var start = startTime.getTime();
        var now = new Date().getTime();
        var differenceInMs = now - start;
        return {
            canRetry: differenceInMs < maxCumulativeWaitTimeMs,
            differenceInMs: differenceInMs
        };
    };
    /**
     * Logs attempt in console.
     * This function is also used for testing in jasmine spy
     */
    RetryService.prototype.debugLogAttempt = function (attempt, waitTime) {
        console.warn("Attempt " + attempt + ": retrying in " + waitTime + "ms");
    };
    RetryService.prototype.getNextWaitTimeMs = function (addJitter, deltaBackoffMs, retryAttempts, retryAfterInMs) {
        if (retryAfterInMs) {
            return retryAfterInMs;
        }
        if (!addJitter) {
            return deltaBackoffMs * Math.pow(2, retryAttempts);
        }
        var from = 0.8 * deltaBackoffMs;
        var to = 1.2 * deltaBackoffMs * Math.pow(2, retryAttempts);
        return this.randomNumberFromInterval(from, to);
    };
    RetryService.prototype.canRetryErrorDefault = function (error) {
        var axiosError = this.tryGetAxiosError(error);
        if (!axiosError) {
            // by default non-axios errors are not retried
            return false;
        }
        var statusCode = this.getStatusCodeFromError(error);
        var canRetryStatusCode = this.canRetryStatusCode(statusCode, this.useRetryForStatusCodes);
        if (canRetryStatusCode) {
            return true;
        }
        return false;
    };
    RetryService.prototype.canRetryStatusCode = function (statusCode, useRetryForResponseCodes) {
        return useRetryForResponseCodes.includes(statusCode);
    };
    RetryService.prototype.isAxiosError = function (error) {
        var _a, _b;
        return (_b = (_a = this.tryGetAxiosError(error)) === null || _a === void 0 ? void 0 : _a.isAxiosError) !== null && _b !== void 0 ? _b : false;
    };
    RetryService.prototype.getStatusCodeFromError = function (error) {
        var axiosError = this.tryGetAxiosError(error);
        if (!axiosError || !axiosError.response) {
            return 0;
        }
        return axiosError.response.status;
    };
    RetryService.prototype.tryGetRetryAfterInMsFromError = function (error) {
        var _this = this;
        var axiosError = this.tryGetAxiosError(error);
        if (!axiosError || !axiosError.response) {
            return undefined;
        }
        var headers = extractHeadersFromAxiosResponse(axiosError.response);
        var retryValueHeader = headers.find(function (m) { return m.header.toLowerCase() === _this.retryAfterHeaderName.toLowerCase(); });
        if (!retryValueHeader) {
            return undefined;
        }
        var retryValue = retryValueHeader.value;
        if (isNaN(+retryValue)) {
            // header is date
            var retryAfter = new Date(retryValue).getTime();
            var now = new Date().getTime();
            var differenceInMs = retryAfter - now;
            return differenceInMs;
        }
        else {
            // header is number
            var retryValueInMs = +retryValue * 1000;
            return retryValueInMs;
        }
    };
    RetryService.prototype.tryGetAxiosError = function (error) {
        if (!error) {
            return undefined;
        }
        if (error.isAxiosError) {
            return error;
        }
        var originalError = error.originalError;
        if (originalError && originalError.isAxiosError) {
            return originalError;
        }
        return undefined;
    };
    /**
     * min and max included
     */
    RetryService.prototype.randomNumberFromInterval = function (min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    };
    return RetryService;
}());
export { RetryService };
export var retryService = new RetryService();
//# sourceMappingURL=retry-service.js.map