import axios from 'axios';
import { defer, from, throwError } from 'rxjs';
import { catchError, map, retryWhen } from 'rxjs/operators';
import { extractHeadersFromAxiosResponse } from './headers-helper';
import * as HttpFunctions from './http.functions';
import { observableRetryStrategy } from './observable-retry-strategy';
import { retryService } from './retry-service';
var HttpService = /** @class */ (function () {
    function HttpService(opts) {
        this.axiosInstance = axios.create(opts && opts.axiosRequestConfig ? opts.axiosRequestConfig : undefined);
        if (opts) {
            if (opts.requestInterceptor) {
                HttpFunctions.registerRequestInterceptor(this.axiosInstance, opts.requestInterceptor);
            }
            if (opts.responseInterceptor) {
                HttpFunctions.registerResponseInterceptor(this.axiosInstance, opts.responseInterceptor);
            }
        }
    }
    HttpService.prototype.get = function (call, options) {
        var _this = this;
        // bind callback from axios promise
        var axiosObservable = defer(function () { return from(HttpFunctions.getCallback(_this.axiosInstance, call, options)); });
        // map axios observable
        return this.mapAxiosObservable(axiosObservable, options);
    };
    HttpService.prototype.post = function (call, options) {
        var _this = this;
        // bind callback from axios promise
        var axiosObservable = defer(function () { return from(HttpFunctions.postCallback(_this.axiosInstance, call, options)); });
        // map axios observable
        return this.mapAxiosObservable(axiosObservable, options);
    };
    HttpService.prototype.put = function (call, options) {
        var _this = this;
        // bind callback from axios promise
        var axiosObservable = defer(function () { return from(HttpFunctions.putCallback(_this.axiosInstance, call, options)); });
        // map axios observable
        return this.mapAxiosObservable(axiosObservable, options);
    };
    HttpService.prototype.patch = function (call, options) {
        var _this = this;
        // bind callback from axios promise
        var axiosObservable = defer(function () { return from(HttpFunctions.patchCallback(_this.axiosInstance, call, options)); });
        // map axios observable
        return this.mapAxiosObservable(axiosObservable, options);
    };
    HttpService.prototype.delete = function (call, options) {
        var _this = this;
        // bind callback from axios promise
        var axiosObservable = defer(function () { return from(HttpFunctions.deleteCallback(_this.axiosInstance, call, options)); });
        // map axios observable
        return this.mapAxiosObservable(axiosObservable, options);
    };
    HttpService.prototype.mapAxiosObservable = function (axiosObservable, options) {
        var _this = this;
        return axiosObservable.pipe(map(function (result) { return _this.mapResult(result); }), retryWhen(observableRetryStrategy.strategy(retryService.getRetryStrategyFromStrategyOptions(options === null || options === void 0 ? void 0 : options.retryStrategy), {
            startTime: new Date()
        })), catchError(function (error) {
            // Handling errors: https://github.com/axios/axios#handling-errors
            if (options && options.logErrorToConsole) {
                console.error("Kentico Kontent Core SDK encountered an error: ", error);
            }
            return throwError(error);
        }));
    };
    HttpService.prototype.mapResult = function (result) {
        // if error is set, throw it
        if (result.error) {
            throw result.error;
        }
        // if neither error nor response is set, throw an error
        if (!result.response) {
            throw Error('Response is not set and no error was thrown');
        }
        return {
            data: result.response.data,
            response: result.response,
            headers: extractHeadersFromAxiosResponse(result.response),
            status: result.response.status
        };
    };
    return HttpService;
}());
export { HttpService };
//# sourceMappingURL=http.service.js.map